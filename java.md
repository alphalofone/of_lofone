<font face = "黑体" size = 7> <center>JAVA </font></center>

-----
<br></br>

# 数据类型和数组
- 美元$也是标识符的组成元素，标识符的首字符不能是数字。
- 整型：byte(1字节8位); short(2字节16位); int(4字节32位); long(8字节64位).
- 字符型：用"\u"转义+4个16进制整数表示Unicode中相对应位置的字符。如: char ch = "\u0041" = 1X1+4X16 = 65 = 'A'. 即Unicode中第65个字符。
- float 保留8位有效数字; double 保留16位有效数字。

```java
int x[] = {3, 4, 5}; //合法声明 //一维数组 //长度为 3

double [] y; //合法声明 //一维数组

float boy[][] = {{1}, {1,2}, {1,2,3}}; //合法声明 //二维数组

char [3][] cat; //合法声明 //二维数组 //第二维可以单独声明

int [] a, b[]; //a是一维数组，b是二维数组
/*a.length 返回数组的长度；b.length 返回一维数组的个数*/

int x[3]; //非法声明，不允许在声明处指定元素个数

int size = 30;
double num[] = new num[size]; //合法,允许使用变量指定元素个数。
System.out.print(""+num); //输出num的引用。
```

# 类

- 面向对象语言相对面向过程需要更多的内存，更快的CPU来保证其速度。
> **多态**
>- 操作名称的多态，即多个操作具有相同的名字，但这些操作所接收的操作类型必须不同
>- 和继承有关的多态，指同一个操作被不同类型对象调用时产生的不同行为
- **类**：变量刻画属性、方法体现行为。用方法操作属性来实现具体的行为。
- 局部变量和成员变量名字相同，成员变量将被隐藏，通过this调用

```java
    y = this.x + x;
```

- 局部变量没有默认值，声明时不赋值的话编译也不会报错。
- 默认构造方法是无参的，且方法体中没有语句。

```java
    Lader(){} //这就是默认构造方法
``` 
    
> **用new运算符创建对象，系统会做两件事：**
>- 为变量分配空间并调用构造函数。如果有变量没有被指定初值，则整型为0、浮点型为0.0、boolean型为false、引用型为null。
>- 计算并返回一个称为引用的值(一个十六进制的数)。即new XiYouJiRenWu()是一个值。

> **传值机制**
>- JAVA中方法的所有参数都是“传值”的。参数变量的值是调用者指定的值的拷贝。
>- 向该参数传递的值的级别不可高于该参数的级别。
>- 对于引用型变量，“传值”传递的是变量中存放的“应用”，而不是变量所引用的实体。

```java
    for(int param : x){
        sum = sum + param;
    } //增强for语句 用于可变参数、数组等的遍历
```

> **组合：一个对象将其他对象作为自己的组成部分。Has-A,属弱耦合关系。**
>- 关联关系：A类中的成员变量是用B类声明的对象。
>- 依赖关系：A类中某个方法的参数使用B类生命的对象或者某个方法返回的数据类型是B类。

- 对象共享类变量。类中的类变量，在该类被加载到内存时，就分配了相应的内存空间。类变量直到程序退出运行才释放所占的空间。

> **类方法和实例方法**
>- 实例方法在第一个对象被创建时分配入口地址，此后可以被其他任何新建对象调用。当此类的所有对象都不存在时入口地址才被取消。
>- 实例方法既可以操作实例变量，也可以操类变量。类方法只能操作类变量和传入的参数。
>- 类方法在该类被加载到内存时就被分配了相应的入口地址，从而类方法可以被该类的任何对象调用，也可以被该类直接调用。类方法的入口地址知道程序结束才被取消。

- 方法重载：一个类中有多个方法具有相同的名字，但方法的参数（个数、顺序、类型）不尽相同。总之要避免歧义。
- import语句可以引入包中的类和接口。也可以直接带着包名使用该类。

```java
    java.util.Date D = new java.util.Date(); //带着包名使用
```
- 程序自动引入java.lang包（包含System类、Math类等）。

> **访问权限**
>- 主要指能否在其他类中通过此类的对象调用实例变量、实例方法，通过类名调用类变量、类方法。
>> 权限|描述|继承
>> :-:|:-:|:-:|:-:
>> public|任意可见，权限极大|随便继承
>> protected| 同一包权限同public；不同包权限同private|可被子孙类继承
>> friendly|默认类型，同protected|仅可被同包子孙类继承
>> private|仅在类体中可见，在其余任何类中隐藏|不可被继承
>- 类的修饰只能由public修饰或无修饰（默认友好类）。
>- 同一源文件属于同一个包。

> **静态块**
>- 在java类中（方法中不能存在静态代码块）使用static关键字和{}声明的代码块：
>- 静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。如果一个类中有多个静态代码块，会按照顺序依次执行。

```java
    public class CodeBlock {
        static{System.out.println("静态代码块");}
    } 
```

# 继承

- JAVA不支持多重继承，一个类只能有一个父类。
- 任何类都是Object类（定义在java.lang包中）的子孙类，class A 等价于 class A extends Object。
- 当子类创建对象的时候，继承的父类的所有成员变量都会被分配空间。

> **隐藏和重写**
>- 子类通过重新定义重名变量可以隐藏从父类继承来的成员变量。
>- 这时子类只能调用子类定义的同名变量，但从父类继承的方法使用的是的仍是调藏的同名变量。
>- 子类可以通过重写隐藏从父类继承来的方法（方法重写）。
>- 重写的方法既可以操作集成的成员变量，调用继承的方法；也可以操作子类新声明的成员变量，调用新定义的其他方法；但无法操作被子类隐藏的成员变量和方法（除非用super）。
>- 在子类中被隐藏的成员变量和方法归super关键字所有。
>- 子类在构造函数中使用super() 来调用父类的构造函数。而且super()必须在第一条语句调用。

```java
class UniverStudent extends Student{
    boolean 婚否;
    UniverStudent(int number, String name, boolean b){
        super(number, name); //第一句，调用父类构造函数
        婚否 = b; //子类
    } //子类构造函数
} //继承
```

> **final关键字**
>- final类不能被继承
>- final方法不能被重写
>- final变量不能被修改，即常量。所以必须在定义时赋初值。

 -|对象|上转型对象
 :-:|:-:|:-:
 隐藏的变量|×|√
 继承的变量|√|√
 新增的变量|√|×
 继承或重写的方法|√|√
 新增的方法|√|×
 - 利用上转型可以实现与继承有关的多态。
 > **abstract关键字**
 >- abstract类可以有abstract方法，也可以有非abstract方法。不能用new创建对象。但可以作为上转型对象。
 >- abstract方法只许声明，不许实现，不允许被final和static修饰。
 >- abstract类的的子类如果是非abstract类，则必须重写所有abstract方法；如果是abstract类，则可以重写一部分abstract方法，继承另一部分。
 
 - 开-闭原则：对扩展开放，对修改关闭。
 
 # 接口

 - 接口包含常量和抽象方法两部分。常量是public static final类型（定义时可省略），方法是public abstract类型（定义时可省略）。
 - 实现接口时必须重写所有的方法。重写接口的方法必须用public修饰（不能降低访问权限）。
 - 实现接口的类可以通过接口名访问接口中的常量。
 - 接口默认仅可被同包中的类体实现，用public修饰可以被任何类实现。
 - 接口可以被子接口继承。
 - 接口回调：可以将实现接口的类所创建的对象的引用赋给接口创建的对象。
 - 
 ```java
 Com com; //接口对象 //空对象
 InplenCom object = new ImplenCom(); //实现接口的类所创建的对象
 com = object； //接口回调 //只能调用接口方法
 ```
 - 但是接口无法调用类中的其他非接口方法。
 
 # 内部类与异常类

 > **内部类**
  >- 内部类的外嵌类成员变量在内部类中仍然有效。内部类的方法也可以调用外嵌类中的方法。
  >- 内部类的类体中不可声明类变量和类方法。外嵌类的类体中可以用内部类声明对象，作为外嵌类的成员。
  >- 内部类仅供它的外嵌类使用。（static另说）
  >- 内部类可以被static修饰(非内部类不可被static修饰)，这样就可以被其他类使用，但是就不能操作外嵌类中的实例成员变量类。

> **匿名类**
>>1. **和子类有关的匿名类**
>>2. **和接口有关的匿名类**
>>- 匿名类可以继承父类的方法，也可以重写父类方法。
>>- 匿名类一定是内部类(可以访问外嵌类的成员变量和方法)。
>>- 匿名类类体中不可以生命static成员变量和static方法。
>>- 匿名类没有构造函数，必须在第一句使用父类的构造方法。

- JAVA使用try-catch语句来处理异常，将可能出现异常的操作放在try{}内，当try{}中出现异常时，try部分将立刻结束执行，转而执行catch部分，完了执行finally部分。

# 实用类

> String类(java.lang包)
>- String类是finally类，不可被继承。
>- 用双引号括起来的字符序列是常量对象，放在常量池中，程序运行期间不可被改变。
>- String对象用"+"进行并置运算。
```java
String s1 = "天道酬勤"; //创建常量字符串储存在变量池中并返回引用
String s2 = "天道酬勤"; //把常量池中的常量字符串的引用赋给 s2
s1 == s2; //true, s1 s2拥有相同的引用。
String s3 = new String("天道酬勤"); //String对象
String s4 = new String("天道酬勤"); //新的String对象 和s3不是同一个引用
s3.equals(s4); //ture s3 s4 拥有相同的字符串序列(不区分大小写)
```
>- 将数字字符转换成数字 : 基本数据类型.parse基本数据类型(String) Byte,Short,Integer,Float,Double.
>- 将数字转换成String对象 : String.valueof(基本数据类型)
>- main方法的args[]参数能接受用户从键盘输入的字符序列，存放在String对象数组中。

> StringTokenizer类(java.util包)
>- 解析字符串 可指定分隔符
>- 用while循环获取分解的字符串

```java
StringTokenizer fenxi = new StringTokeniezer("You#*are*##welcome", "#*"); 
/* #*的任意排列都是分隔符 */
while(fenxi.hasMoreTokens){
    String item = fenxi.nextToken();
}
```

# 组件及事件处理
- 事件源调用自身注册监视器的方法将实现接口的A类的对象注册为监视器。
- 当事件源发生XXX事件时，监视器调用自身的处理XXX事件的接口方法来处理事件。
- A类必须实现事件源发生相应事件的接口方法供注册器调用。
- 监视器通过接口回调来调用实现接口的方法。

---
![event](event.png "deal with event")
---


# I/O操作

- 打开或者创建一个文件 File f = new File("C:/user/lofone", "hello.txt"); //不指定路径默认当前路径。

> **输入流**
>1. 设定输入流的源。
>2. 创建指向源的输入流。
>3. 让输入流读取源中的数据。
>4. 关闭输入流。

```java
File f = new File("hello.txt"); // 1
FileInputStream in = new FileInputStream(f); // 2
in.read(); // 3 //读取单个字节数据
in.close(); // 4
```
> **输出流**
>1. 给定输出流的目的地。
>2. 创建指向目的地的输出流。
>3. 让输出流把数据写入到目的地。
>4. 关闭输出路。

```java
File f = new File("hello.txt"); // 1
FileOuputtStream out = new FileOutputStream(f); // 2
out.write(); // 3 //写入单个字节数据
out.close(); // 4
