***JAVA***

# 类
- 面向对象语言需要消耗更多的内存，使用更快的CPU来保证其速度
>多态
>- 操作名称的多态，即多个操作具有相同的名字，但这些操作所接收的操作类型必须不同
>- 和继承有关的多态，指同一个操作被不同类型对象调用时产生的不同行为
- 类：变量刻画属性、方法体现行为。用方法操作属性来实现具体的行为。
- 局部变量和成员变量名字相同，成员变量将被隐藏，通过this调用

```
    y = this.x + x;
```
- 局部变量没有默认值
- 默认构造方法是无参的，且方法体中没有语句

```
    Lader(){} //这就是默认构造方法
``` 
    
> 用new运算符创建对象，系统会做两件事：
>- 为变量分配空间并调用构造函数。如果有变量没有被指定初值，则整型为0、浮点型为0.0、boolean型为false、引用性为null。
>- 计算并返回一个称为引用的值(一个十六进制的数)。即new XiYouJiRenWu()是一个值。

> 传值机制
>- JAVA中方法的所有参数都是“传值”的。参数变量的值是调用者指定的值的拷贝。
>- 向该参数传递的值的级别不可高于该参数的级别。
>- 对于引用型变量，“传值”传递的是变量中存放的“应用”，而不是变量所引用的实体。

```
    for(int param : x){
        sum = sum + param;
    } //增强for语句 用于可变参数、数组等的遍历
```

> 组合：一个对象将其他对象作为自己的组成部分。Has-A,属弱耦合关系。
>- 关联关系：A类中的成员变量是用B类声明的对象。
>- 依赖关系：A类中某个方法的参数使用B类生命的对象或者某个方法返回的数据类型是B类。
- 对象共享类变量。类中的类变量，在该类被加载到内存时，就分配了相应的内存空间。类变量直到程序退出运行才释放所占的空间。
>类方法和实例方法
>- 实例方法在第一个对象被创建时分配入口地址，此后可以被其他任何新建对象调用。当此类的所有对象都不存在时入口地址才被取消。
>- 实例方法既可以操作实例变量，也可以操类变量。类方法不可操作实例变量。
>- 类方法在该类被加载到内存时就被分配了相应的入口地址，从而类方法可以被该类的任何对象调用，也可以被该类直接调用。类方法的入口地址知道程序结束才被取消。

- 方法重载：一个类中有多个方法具有相同的名字，但芳发的参数（个数、顺序、类型）不尽相同。总之要避免歧义。
- import语句可以引入包中的类和接口。也可以直接带着包名使用该类。

```
    java.util.Date D = new java.util.Date();
```
- 程序自动引入java.lang包（包含System类、Math类等）。

> 访问权限
>- 主要指能否在其他类中通过此类的对象调用实例变量、实例方法，通过类名调用类变量、类方法。
>> 权限|描述|继承
>> -|:-|:-|:-:
>> public|任意可见，权限极大|随便继承
>> protected| 同一包同public，不同包同private|可被子孙类继承
>> friendly|默认类型，同protected|仅可被同包子孙类继承
>> private|仅在类体中可见，在其余任何类中隐藏|不可被继承
>- 类的修饰只能由public修饰或无修饰（默认友好类）。
>- 同一源文件属于同一个包。

>静态块
>- 在java类中（方法中不能存在静态代码块）使用static关键字和{}声明的代码块：
>- 静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于各种代码块以及构造函数。如果一个类中有多个静态代码块，会按照顺序依次执行。
```
    public class CodeBlock {
        static{System.out.println("静态代码块");}
    } 
```
# 继承
- JAVA不支持多重继承，一个类只能有一个父类。
- 任何类都是Object类（定义在java.lang包中）的子孙类，class A 等价于 class A extends Object。
- 当子类创建对象的时候，继承的父类的所有成员变量都会被分配空间。

> 隐藏和重写
>- 子类通过重新定义重名变量可以隐藏从父类继承来的成员变量。
>- 这时子类只能调用子类定义的同名变量，但从父类继承的方法使用的是的仍是调藏的同名变量。
>- 子类可以通过重写隐藏从父类继承来的方法（方法重写）。
>- 重写的方法既可以操作集成的成员变量，调用继承的方法；也可以操作子类新声明的成员变量，调用新定义的其他方法；但无法操作被子类隐藏的成员变量和方法（除非用super）。
>- 在子类中被隐藏的成员变量和方法归super关键字所有。
>- 子类在构造函数中使用super() 来调用父类的构造函数。而且super()必须在第一条语句调用。
```
class UniverStudent extends Student{
    boolean 婚否;
    UniverStudent(int number, String name, boolean b){
        super(number, name); //第一句，调用父类构造函数
        婚否 = b; //子类
    } //子类构造函数
} //继承
```
>final关键字
>- final类不能被继承
>- final方法不能被重写
>- final变量不能被修改，即常量。所以必须在定义时赋初值。

 -|对象|上转型对象
 -|:-|:-:
 隐藏的变量|×|√
 继承的变量|√|√
 新增的变量|√|×
 继承或重写的方法|√|√
 新增的方法|√|×
 - 利用上转型可以实现与继承有关的多态。
 > abstract关键字
 >- abstract类可以有abstract方法，也可以有非abstract方法。不能用new创建对象。但可以作为上转型对象。
 >- abstract方法只许声明，不许实现，不允许被final和static修饰。
 >- abstract类的的子类如果是非abstract类，则必须重写所有abstract方法；如果是abstract类，则可以重写一部分abstract方法，继承另一部分。
 
 - 开-闭原则：对扩展开放，对修改关闭。
 
 # 接口
 - 接口包含常量和抽象方法两部分。常量是public static final类型（定义时可省略），方法是public abstract类型（定义时可省略）。
 - 实现接口时必须重写所有的方法。重写接口的方法必须用public修饰（不能降低访问权限）。
 - 实现接口的类可以通过接口名访问接口中的常量。
 - 接口默认仅可被同包中的类体实现，用public修饰可以被任何类实现。
 - 接口可以被子接口继承。
 - 接口回调：可以将实现接口的类所创建的对象的引用赋给接口创建的对象。
 ```
 Com com; //接口对象 //空对象
 InplenCom object = new ImplenCom(); //实现接口的类所创建的对象
 com = object； //接口回调 //只能调用接口方法
 ```
 - 但是接口无法调用类中的其他非接口方法。
 
 # 内部类与异常类
 >内部类
  >- 内部类的外嵌类成员变量在内部类中仍然有效。内部类的方法也可以调用外嵌类中的方法。
  >- 内部类的类体中不可声明类变量和类方法。外嵌类的类体中可以用内部类声明对象，作为外嵌类的成员。
  >- 内部类仅供它的外嵌类使用。（static另说）
  >- 内部类可以被static修饰(非内部类不可被static修饰)，这样就可以被其他类使用，但是就不能操作外嵌类中的实例成员变量类。


